const microzig = @import("microzig");
const mmio = microzig.mmio;

/// Sources
/// ARM DDI 0337H  Cortex-M3 Revision r2p0 Technical Reference Manual
/// ARM DDI 0403E.e Arm®v7-M Architecture Reference Manual

// External Private Peripheral Bus
const rom_table_base = 0xE00FF000;
const ext_ppb_base = 0xE0042000;
const etm_base = 0xE0041000;
const tpiu_base = 0xE0040000;

// Internal Private Peripheral Bus
const scs_base = 0xE000E000;
const fpb_base = 0xE0003000;
const dwt_base = 0xE0002000;
const itm_base = 0xE0000000;

//  SCS
//    System control and ID registers
//      0xE000E000-0xE000E00F Includes the Interrupt Controller Type and Auxiliary Control registers
///     0xE000ED00-0xE000ED8F System Control Block
const SCB = extern struct {
    /// CPUID Base Register, CPUID Specifies: the ID number of the processor core, the version number of the processor core
    /// and, the implementation details of the processor core.
    CPUID: mmio.Mmio(packed struct(u32) {
        /// Indicates patch release: 0x0 = Patch 0.
        REVISION: u4,
        /// Indicates part number: 0xC23 = Cortex-M3
        PARTNO: u12,
        ///  Reads as 0xF
        _Constant: u4 = 0xF,
        ///  Indicates processor revision: 0x2 = Revision 2
        VARIANT: u4,
        /// Indicates implementor: 0x41 = ARM
        IMPLEMENTER: u8,
    }),
    /// Interrupt Control and State Register, ICSR:
    ///  Provides software control of the NMI, PendSV, and SysTick exceptions, and provides
    ///  interrupt status information.
    ///
    /// The effect is unpredictable if a write to the ICSR:
    /// • Sets both PENDSVSET and PENDSVCLR to 1.
    /// • Sets both PENDSTSET and PENDSTCLR to 1.
    ICSR: mmio.Mmio(packed struct(u32) {
        /// The exception number of the current executing exception. A value of 0 indicates that the
        /// processor is in Thread mode.
        VECTACTIVE: u9,
        _reserved0: u2 = 0,
        /// In Handler mode, indicates whether there is an active exception other than the exception
        /// indicated by the current value of the IPSR.
        /// In Thread mode the value of this bit is UNKNOWN.
        RETTOBASE: enum(u1) {
            @"There is an active exception other than the exception shown by IPSR",
            @"There is no active exception other than any exception shown by IPSR",
        },
        /// The exception number of the highest priority pending and enabled interrupt. A value of 0
        /// indicates that there is no pending exception.
        /// If DHCSR.C_MASKINTS is set, then PendSV, SysTick, and configurable external
        /// interrupts are masked and will not be shown as pending in VECTPENDING.
        VECTPENDING: u9,
        _reserved1: u1 = 0,
        /// Indicates whether an external interrupt, generated by the NVIC, is pending
        /// 0 No external interrupt pending.
        /// 1 External interrupt pending
        /// The value of DHCSR.C_MASKINTS is ignored
        ISRPENDING: u1,
        /// Indicates whether a pending exception will be serviced on exit from debug halt state
        /// 0 Will not service.
        /// 1 Will service a pending exception.
        /// This bit is read-only.
        ISRPREEMPT: u1,
        _reserved2: u1 = 0,
        /// Removes the pending status of the SysTick exception
        /// 0 No effect.
        /// 1 Remove pending status.
        /// This bit is write only
        PENDSTCLR: u1,
        /// On writes, sets the SysTick exception as pending. On reads, indicates the current state of the exception
        /// 0 On writes, has no effect. On reads, SysTick is not pending.
        /// 1 On writes, make SysTick exception pending. On reads, SysTick is pending.
        PENDSTSET: u1,
        /// Removes the pending status of the PendSV exception
        /// 0 No effect.
        /// 1 Remove pending status.
        /// This bit is write only
        PENDSVCLR: u1,
        ///On writes, sets the PendSV exception as pending. On reads, indicates the current state of the
        /// exception:
        /// 0 On writes, has no effect. On reads, PendSV is not pending.
        /// 1 On writes, make PendSV exception pending. On reads, PendSV is pending.
        /// Normally, software writes 1 to this bit to request a context switch.
        PENDSVSET: u1,
        _reserved3: u2 = 0,
        /// On writes, makes the NMI exception active. On reads, indicates the state of the exception:
        /// 0 On writes, has no effect. On reads, NMI is inactive.
        /// 1 On writes, make the NMI exception active. On reads, NMI is active.
        /// Because NMI is higher priority than other exceptions, if the processor is not already
        /// executing the NMI handler, it enters the NMI exception handler as soon as it recognizes the
        /// write to this bit
        NMIPENDSET: u1,
    }),
    /// Vector Table Offset Register, VTOR: Holds the vector table address.
    /// One or two of the high-order bits of the TBLOFF field can be implemented as RAZ/WI,
    /// reducing the supported address range. For example, if two bits are implemented as RAZ/WI,
    /// then TBLOFF[29:7] defines bits[29:7] of the address.
    VTOR: u32,
    /// Application Interrupt and Reset Control Register, AIRCR
    /// Sets or returns interrupt control data.
    AIRCR: mmio.Mmio(packed struct(u32) {
        /// Writing 1 to this bit causes a local system reset, see Reset management on page B1-559 for
        /// more information. This bit self-clears.
        /// The effect of writing a 1 to this bit if the processor is not halted in Debug state is UNPREDICTABLE.
        /// When the processor is halted in Debug state, if a write to the register writes a 1 to both
        /// VECTRESET and SYSRESETREQ, the behavior is UNPREDICTABLE.
        /// This bit is write only.
        VECTRESET: u1,
        /// Writing 1 to this bit clears all active state information for fixed and configurable exceptions.
        /// This includes clearing the IPSR to zero,
        /// The effect of writing a 1 to this bit if the processor is not halted in Debug state is UNPREDICTABLE.
        /// This bit is write only.
        VECTCLRACTIVE: u1,
        /// System Reset Request
        /// 0 Do not request a reset.
        /// 1 Request reset.
        /// Writing 1 to this bit asserts a signal to the external system to request a Local reset.
        /// A Local or power-on reset clears this bit to 0.
        SYSRESETREQ: u1,
        _reserved0: u5 = 0,
        /// Priority grouping, indicates the binary point position.
        /// This field resets to 0b000.
        PRIGROUP: u3,
        _reserved1: u4 = 0,
        ENDIANNESS: enum(u1) {
            Little_endian,
            Big_endian,
        },
        /// Write: VECTKEY
        /// Read: VECTKEYSTAT
        /// Vector Key.
        /// Register writes must write 0x05FA to this field, otherwise the write is ignored.
        /// On reads, returns 0xFA05.
        VECTKEY: u16 = 0x05FA,
    }),
    /// System Control Register, SCR: Sets or returns system control data.
    SCR: mmio.Mmio(packed struct(u32) {
        _reserved0: u1 = 0,
        /// Determines whether, on an exit from an ISR that returns to the base level of execution
        /// 0 priority, the processor enters a sleep state:
        /// 1 Do not enter sleep state.
        /// Enter sleep state.
        SLEEPONEXIT: u1,
        /// Provides a qualifying hint indicating that waking from sleep might take longer. An
        /// implementation can use this bit to select between two alternative sleep states:
        /// 0 Selected sleep state is not deep sleep.
        /// 1 Selected sleep state is deep sleep.
        /// Details of the implemented sleep states, if any, and details of the use of this bit, are
        /// IMPLEMENTATION DEFINED.
        /// If the processor does not implement a deep sleep state then this bit can be RAZ/WI.
        SLEEPDEEP: u1,
        _reserved1: u1 = 0,
        /// Determines whether an interrupt transition from inactive state to pending state is a wakeup event
        /// 0 Transitions from inactive to pending are not wakeup events.
        /// 1 Transitions from inactive to pending are wakeup events.
        SEVONPEND: u1,
        _reserved2: u27,
    }),
    /// Configuration and Control Register, CCR:
    /// Sets or returns configuration and control data, and provides control over caching and branch
    /// prediction.
    CCR: mmio.Mmio(packed struct(u32) {
        /// Non-base Thread Enable: Controls whether the processor can enter Thread mode with exceptions active
        /// * if the number of active exceptions is non-zero and does not rely on execution priority boosting including BASEPRI, FAULTMASK and PRIMASK
        NONBASETHRDENA: enum(u1) {
            @"Any attempt to return to Thread mode will result in an exception*",
            @"The processor can enter Thread mode with exceptions active because of a controlled return value",
        },
        /// Controls whether unprivileged software can access the STIR
        /// 0 Unprivileged software cannot access the STIR.
        /// 1 Unprivileged software can access the STIR.
        USERSETMPEND: u1,
        _reserved0: u1 = 0,
        /// Controls the trapping of unaligned word or halfword accesses
        /// Unaligned load-store multiples and word or halfword exclusive accesses always fault.
        UNALIGN_TRP: u1,
        /// Controls the trap on divide by 0
        /// if no fault occurs 0 is returned
        DIV_0_TRP: u1,
        _reserved1: u3,
        /// Bus Fault Handler and HardFault Non-Maskable Interrupt Generation
        /// Determines the effect of precise data access faults on handlers running at priority -1 or priority -2
        /// 0  Precise data access fault causes a lockup
        /// 1  Handler ignores the fault
        BFHFNMIGN: u1,
        /// Determines whether the exception entry sequence guarantees 8-byte stack frame alignment,
        /// adjusting the SP if necessary before saving state:
        /// 0 Guaranteed SP alignment is 4-byte, no SP adjustment is performed.
        /// 1 8-byte alignment guaranteed, SP adjusted if necessary.
        /// Whether this bit is RO or RW is IMPLEMENTATION DEFINED.
        /// The reset value of this bit is IMPLEMENTATION DEFINED. Arm recommends that this bit resets to 1.
        STKALIGN: u1,
        _reserved2: u6 = 0,
        /// Cache enable bit. This is a global enable bit for data and unified caches.
        /// 0 Data and unified caches disabled.
        /// 1 Data and unified caches enabled.
        /// If the system does not implement any data or unified caches that can be accessed by the
        /// processor at any level of the memory hierarchy, this bit is RAZ/WI.
        /// If the system implements any data or unified caches that can be accessed by the processor
        /// then it must be possible to disable them by setting this bit to 0.
        DC: u1,
        /// Instruction cache enable bit. This is a global enable bit for instruction caches. The possible
        /// values of this bit are:
        /// 0 Instruction caches disabled.
        /// 1 Instruction caches enabled.
        /// If the system does not implement any instruction caches that can be accessed by the
        /// processor at any level of the memory hierarchy, this bit is RAZ/WI.
        /// If the system implements any instruction caches that can be accessed by the processor then
        /// it must be possible to disable them by setting this bit to 0.
        IC: u1,
        /// Branch prediction enable bit. The possible values of this bit are:
        /// 0 Program flow prediction disabled.
        /// 1 Program flow prediction enabled.
        /// Setting this bit to 1 enables branch prediction, also called program flow prediction.
        /// If program flow prediction cannot be disabled, this bit is RAO/WI.
        /// If the implementation does not support program flow prediction, this bit is RAZ/WI.
        BP: u1,
        _reserved3: u13 = 0,
    }),
    /// System Handler Priority Register
    /// Sets or returns priority for system handlers 4-15
    /// 0 -> PRI_4 -> MemManage
    /// 1 -> PRI_5 -> BusFault
    /// 2 -> PRI_6 -> UsageFault
    /// 3 -> PRI_7
    /// 4 -> PRI_8
    /// 5 -> PRI_9
    /// 6 -> PRI_10
    /// 7 -> PRI_11 -> SVCall
    /// 8 -> PRI_12 -> DebugMonitor
    /// 9 -> PRI_13
    /// 10 -> PRI_14 -> PendSV
    /// 11 -> PRI_15 -> SysTick
    SHPR: [12]u8,
    /// System Handler Control and State Register, SHCSR
    /// Controls and provides the active and pending status of system exceptions.
    SHCSR: mmio.Mmio(packed struct(u32) {
        /// MemManage Fault is active
        MEMFAULTACT: u1,
        /// BusFault is active
        BUSFAULTACT: u1,
        _reserved0: u1 = 0,
        /// UsageFault is active
        USGFAULTACT: u1,
        _reserved1: u3 = 0,
        /// SVCall is active
        SVCALLACT: u1,
        /// Monitor is active
        MONITORACT: u1,
        _reserved2: u1 = 0,
        /// PendSV is active
        PENDSVACT: u1,
        /// Systick is active
        SYSTICKACT: u1,
        /// UsageFault is pending
        USGFAULTPENDED: u1,
        /// MemManage is pending
        MEMFAULTPENDED: u1,
        /// BusFault is pending
        BUSFAULTPENDED: u1,
        /// SVCall is pending
        SVCALLPENDED: u1,
        /// Enable MemManage fault
        MEMFAULTENA: u1,
        /// Enable BusFault
        BUSFAULTENA: u1,
        /// Enable UsageFault
        USGFAULTENA: u1,
        _reserved3: u13 = 0,
    }),
    /// Configurable Fault Status Register, CFSR
    /// UsageFault, bits[31:16] Provides information on UsageFault exceptions.
    /// BusFault, bits[15:8] Provides information on BusFault exceptions.
    /// MemManage, bits[7:0] Provides information on MemManage exceptions.
    CFSR: mmio.Mmio(packed struct(u32) {
        /// Instruction Access Violation
        /// The fault is signaled only if the instruction is issued.
        IACCVIOL: enum(u1) {
            @"No Fault Has Occurred",
            @"MPU or Execute Never (XN) default memory map access violation on an instruction fetch has occurred",
        },
        /// Data Access Violation
        DACCVIOL: enum(u1) {
            @"No Fault Has Occurred",
            @"Data access violation. The MMFAR shows the data address that the load or store tried to access",
        },
        _reserved0: u1 = 0,
        /// MemManage Unstack Error
        MUNSTKERR: enum(u1) {
            @"No Fault Has Occurred",
            @"A derived MemManage fault occurred on exception return",
        },
        /// MemManage Stack Error
        MSTKERR: enum(u1) {
            @"No Fault Has Occurred",
            @"A derived MemManage fault occurred on exception entry",
        },
        /// MemManage Lazy State Preservation Error
        MLSPERR: enum(u1) {
            @"No Fault Has Occurred",
            @"A MemManage fault occurred during FP lazy state preservation.",
        },
        _reserved1: u1 = 0,
        /// Memory Management Address Register Valid
        /// MMFAR - Memory Management Fault Address Register status
        MMARVALID: enum(u1) {
            @"MMFAR does not have valid contents",
            @"MMFAR has valid contents",
        },
        /// Instruction Bus Error
        /// the fault is signaled only if the instruction is issued
        IBUSERR: enum(u1) {
            @"No Fault Has Occurred",
            @"A bus fault on an instruction prefetch has occurred",
        },
        /// Precise Data Bus Error
        /// processor will write the faulting address to the BFAR.
        PRECISERR: enum(u1) {
            @"No Fault Has Occurred",
            @"A precise data access error has occurred",
        },
        /// Imprecise Data Bus Error
        IMPRECISERR: enum(u1) {
            @"No Fault Has Occurred",
            @"Imprecise data access error has occurred",
        },
        /// Unstacking Error
        UNSTKERR: enum(u1) {
            @"No Fault Has Occurred",
            @"A derived bus fault has occurred on exception return",
        },
        /// Stacking Error
        STKERR: enum(u1) {
            @"No Fault Has Occurred",
            @"A derived bus fault has occurred on exception entry",
        },
        ///  Lazy State Preservation Error
        LSPERR: enum(u1) {
            @"No Fault Has Occurred",
            @"A bus fault occurred during FP lazy state preservation",
        },
        _reserved2: u1 = 0,
        /// Bus Fault Address Register Valid
        BFARVALID: enum(u1) {
            @"BFAR does not have valid contents",
            @"BFAR has valid contents",
        },
        /// Undefined Instruction
        /// This might be an undefined instruction associated with an enabled coprocessor
        UNDEFINSTR: enum(u1) {
            @"No Fault Has Occurred",
            @"The processor has attempted to execute an undefined instruction",
        },
        /// Invalid State
        INVSTATE: enum(u1) {
            @"No Fault Has Occurred",
            @"Instruction executed with invalid EPSR.T or EPSR.IT field",
        },
        /// Invalid Program Counter
        INVPC: enum(u1) {
            @"No Fault Has Occurred",
            @"An integrity check error has occurred on EXC_RETURN",
        },
        /// No Coprocessor
        /// This also shows that the coprocessor is disabled or not present.
        NOCP: enum(u1) {
            @"No Fault Has Occurred",
            @"A coprocessor access error has occurred, or coprocessor is disabled or not present",
        },
        _reserved3: u4 = 0,
        /// Unaligned Access
        /// Multi-word accesses always fault if not word aligned. Software can configure unaligned
        /// word and halfword accesses to fault, by enabling UNALIGN_TRP in the CCR
        UNALIGNED: enum(u1) {
            @"No Fault Has Occurred",
            @"Unaligned access error has occurred",
        },
        /// Divide by Zero
        /// When SDIV or UDIV instruction is used with a divisor of 0, this fault occurs if DIV_0_TRP is
        /// enabled in the CCR
        DIVBYZERO: enum(u1) {
            @"No Fault Has Occurred",
            @"Divide by zero error has occurred",
        },
        _reserved4: u6 = 0,
    }),
    /// HardFault Status Register, HFSR
    /// Shows the cause of any HardFault.
    HFSR: mmio.Mmio(packed struct(u32) {
        _reserved0: u1 = 0,
        /// Vector Table Read Fault: Indicates when a fault has occurred because of a vector table read error on exception processing
        VECTTBL: enum(u1) {
            @"No Fault Has Occurred",
            @"Vector table read fault has occurred",
        },
        _reserved1: u28 = 0,
        /// Forced Hard Fault: Indicates that a fault with configurable priority has been escalated to a HardFault exception,
        /// because it could not be made active, because of priority or because it was disabled
        FORCED: enum(u1) {
            @"No Fault Has Occurred",
            @"Processor has escalated a configurable-priority exception to HardFault",
        },
        /// DEBUG EVENT: Indicates when a Debug event has occurred
        /// The processor sets this bit to 1 only when Halting debug is disabled and a Debug event occurs
        DEBUGEVT: enum(u1) {
            @"No Debug event has occurred",
            @"Debug event has occurred. The Debug Fault Status Register has been updated",
        },
    }),
    ///Debug Fault Status Register, DFSR
    /// Writing 1 to a register bit clears the bit to 0.
    DFSR: mmio.Mmio(packed struct(u32) {
        /// Indicates a debug event generated by either:
        /// • A C_HALT or C_STEP request, triggered by a write to the DHCSR
        /// • A step request triggered by setting DEMCR.MON_STEP to 1
        HALTED: u1,
        /// BREAKPOINT: Indicates a debug event generated by BKPT instruction execution or a breakpoint match in Flash Patch and Breakpoint (FPB) unit
        BKPT: u1,
        /// Data Watchpoint and Trace event generated
        DWTTRAP: u1,
        /// Vector catch triggerd
        /// The corresponding FSR shows the primary cause of the exception
        VCATCH: u1,
        /// Indicates a debug event generated because of the assertion of an external debug request
        EXTERNAL: u1,
        _reserved1: u27 = 0,
    }),
    /// MemManage Fault Address Register, MMFAR
    /// Shows the address of the memory location that caused an MPU fault.
    /// Valid only when MMFSR.MMARVALID is set, otherwise reads as UNKNOWN.
    MMFAR: u32,
    /// BusFault Address Register, BFAR
    /// Shows the address associated with a precise data access fault.
    /// Valid only when BFSR.BFARVALID is set, otherwise reads as UNKNOWN.
    BFAR: u32,
    /// Auxiliary Fault Status Register, AFSR
    /// Provides implementation-specific fault status information and control.
    /// The contents of this register are IMPLEMENTATION DEFINED.
    AFSR: u32,
    // Processor Feature Register 0, ID_PFR0
    /// Gives top-level information about the instruction sets supported by the processor. This
    /// register is part of the Identification registers functional group.
    ID_PFR0: mmio.Mmio(packed struct(u32) {
        /// Arm instruction set support
        State0: enum(u4) { @"The processor does not support the Arm instruction set", @"Armv7-M reserved" },
        /// Thumb instruction set support
        State1: enum(u4) {
            @"Armv7-M reserved0",
            @"Armv7-M reserved1",
            @"Armv7-M reserved2",
            @"Support for Thumb encoding including Thumb-2 technology, with all basic 16-bit and 32-bit instructions",
        },
        State2: u4,
        State3: u4,
        _reserved0: u16,
    }),

    ///Processor Feature Register 1, ID_PFR1
    /// Gives top-level information about the instruction sets supported by the processor. This
    /// register is part of the Identification registers functional group.
    ID_PFR1: mmio.Mmio(packed struct(u32) {
        _reserved0: u8,
        @"M profile programmers model": enum(u4) {
            @"Armv7-M reserved",
            Reserved,
            @"Two-stack programmers model supported",
        },
        _reserved1: u20,
    }),
    ///Debug Feature Register 0, ID_DFR0
    ID_DFR0: mmio.Mmio(packed struct(u32) {
        _reserved0: u20,
        @"Debug model, M profile": enum(u4) {
            @"Not supported",
            @"Support for M profile Debug architecture, with memory-mapped access",
        },
        _reserved1: u8,
    }),
    /// Auxiliary Feature ID register
    ID_AFR0: u32,
    /// Memory Model Feature Register
    MMFR: [4]u32,
    /// Instruction Set Attributes Register
    ISAR: [5]u32,
    RESERVED0: [5]u32,
    /// Coprocessor Access Control Register, CPACR
    /// Specifies the access privileges for coprocessors.
    /// If a coprocessor is not implemented, a write of 0b01 or 0b11 to the corresponding CPACR field reads back as 0b00.
    CPACR: mmio.Mmio(packed struct(u32) {
        CP0: enum(u2) { @"Access denied", @"Privileged access only", Reserved, @"Full access" },
        CP1: enum(u2) { @"Access denied", @"Privileged access only", Reserved, @"Full access" },
        CP2: enum(u2) { @"Access denied", @"Privileged access only", Reserved, @"Full access" },
        CP3: enum(u2) { @"Access denied", @"Privileged access only", Reserved, @"Full access" },
        CP4: enum(u2) { @"Access denied", @"Privileged access only", Reserved, @"Full access" },
        CP5: enum(u2) { @"Access denied", @"Privileged access only", Reserved, @"Full access" },
        CP6: enum(u2) { @"Access denied", @"Privileged access only", Reserved, @"Full access" },
        CP7: enum(u2) { @"Access denied", @"Privileged access only", Reserved, @"Full access" },
        _reserved0: u4 = 0,
        /// Typical FPU coprocessor location
        CP10: enum(u2) { @"Access denied", @"Privileged access only", Reserved, @"Full access" },
        CP11: enum(u2) { @"Access denied", @"Privileged access only", Reserved, @"Full access" },
        _reserved1: u8 = 0,
    }),
    /// Floating Point Context Control Register, FPCCR: Holds control data for the Floating Point Unit.
    /// Accessible only by privileged software. If the FP extension is not implemented, the FPCCR register location is reserved.
    FPCCR: u32,
    /// Floating Point Context Address Register, FPCAR
    FPCAR: u32,
    /// Floating Point Default Status Control Register, FPDSCR
    FPDSCR: u32,
    /// Interrupt Controller Type Register, ICTR
    /// Provides information about the interrupt controller.
    ICTR: mmio.Mmio(packed struct(u32) {
        /// The total number of interrupt lines supported by an implementation, defined in groups of
        /// 32. That is, the total number of interrupt lines is up to (32*(INTLINESNUM+1)). However,
        /// the absolute maximum number of interrupts is 496, corresponding to the INTLINESNUM
        /// value 0b1111
        INTLINESNUM: enum(u4) { @"32", @"64", @"96", @"128", @"160", @"192", @"224", @"256", @"288", @"320", @"352", @"384", @"416", @"448", @"480", @"496" },
        _reserved0: u28 = 0,
    }),
    /// Auxiliary Control Register - Disables certain aspects of functionality within the processor.
    ACTLR: mmio.Mmio(packed struct(u32) {
        /// Disables interruption of multi-cycle instructions. This increases the interrupt latency of the processor
        /// because load/store and multiply/divide operations complete before interrupt stacking occurs.
        DISMCYCINT: u1,
        /// Disables write buffer use during default memory map accesses. This causes all bus faults to be precise,
        /// but decreases the performance of the processor because stores to memory must complete before the
        /// next instruction can be executed.
        DISDEFWBUF: u1,
        /// Disables folding of IT instructions.
        DISFOLD: u1,
        _reserved0: u29,
    }),
    /// Software Triggered Interrupt Register, STIR: Provides a mechanism for software to generate an interrupt.
    /// This register applies to implemented external interrupts only.
    STIR: mmio.Mmio(packed struct(u32) {
        /// Indicates the interrupt to be triggered. The value written is (ExceptionNumber - 16)
        /// Writing to this register has the same effect as setting the NVIC ISPR bit corresponding to the interrupt to 1
        INTID: u9,
        _reserved: u23 = 0,
    }),
};
//      0xE000EDF0-0xE000EEFF Debug registers in the SCS
//      0xE000EF00-0xE000EF4F Includes the SW Trigger Interrupt Register
//      0xE000EF50-0xE000EF8F Cache and branch predictor maintenance
//      0xE000EF90-0xE000EFCF IMPLEMENTATION DEFINED
//      0xE000EFD0-0xE000EFFF Microcontroller-specific ID space
///   SysTick
///     0xE000E010-0xE000E0FF System Timer
const Systick = extern struct {
    /// SysTick Control and Status Register, SYST_CSR
    /// Controls the system timer and provides status data
    CSR: mmio.Mmio(packed struct(u32) {
        /// ENABLE: Indicates the enabled status of the SysTick counter
        ENABLE: u1,
        /// TICKINT: Indicates whether counting to 0 causes the status of the SysTick exception to change to pending
        TICKINT: u1,
        /// CLKSOURCE: Indicates the SysTick clock source
        CLKSOURCE: enum(u1) { EXTERNAL_REFERENCE_CLOCK, PROCESSOR_CLOCK },
        _reserved0: u13 = 0,
        /// COUNTFLAG: Indicates whether the counter has counted to 0 since the last read of this register
        ///
        /// COUNTFLAG is set to 1 by a count transition from 1 to 0.
        ///
        /// COUNTFLAG is cleared to 0 by a software read of this register, and by any write to the
        /// Current Value register. Debugger reads do not clear the COUNTFLAG.
        COUNTFLAG: u1,
        _reserved1: u15 = 0,
    }),

    /// SysTick Reload Value Register, SYST_RVR
    /// Holds the reload value of the SYST_CVR
    RVR: mmio.Mmio(packed struct(u32) {
        ///RELOAD: The value to load into the SYST_CVR when the counter reaches 0
        RELOAD: u24,
        _reserved0: u8 = 0,
    }),

    /// SysTick Current Value Register, SYST_CVR
    /// Reads or clears the current counter value
    ///
    /// • Any write to the register clears the register to zero
    /// • The counter does not provide read-modify-write protection.
    /// • Unsupported bits are read as zero
    CVR: u32,

    /// SysTick Calibration value Register, SYST_CALIB
    /// Reads the calibration value and parameters for SysTick.
    CALIB: mmio.Mmio(packed struct(u32) {
        /// TENMS: Optionally, holds a reload value to be used for 10ms (100Hz) timing, subject to system clock
        /// skew errors. If this field is zero, the calibration value is not known.
        TENMS: u24,
        _reserved0: u6,
        /// SKEW: Indicates whether the 10ms calibration value is exact
        SKEW: enum(u1) {
            @"10ms calibration value is exact",
            @"10ms calibration value is inexact, because of the clock frequency",
        },
        /// NOREF: Indicates whether the IMPLEMENTATION DEFINED reference clock is implemented
        /// When this bit is 1, the CLKSOURCE bit of the SYST_CSR register is forced to 1 and cannot be cleared to 0
        NOREF: enum(u1) {
            @"The reference clock is implemented",
            @"The reference clock is not implemented",
        },
    }),
};
///   Nested Vectored Interrupt Controller
///     0xE000E100-0xE000ECFF External interrupt controller
const NVIC = extern struct {
    /// Interrupt Set-Enable Registers, NVIC_ISER0-NVIC_ISER15: Enables, or reads the enable state of a group of interrupts.
    /// NVIC_ISERn[31:0] are the set-enable bits for interrupts (31+(32*n)) - (32*n).
    /// When n=15, bits[31:16] are reserved
    ISER: [16]u32,
    _reserved0: [16]u32,
    /// Interrupt Clear-Enable Registers, NVIC_ICER0-NVIC_ICER15: Disables, or reads the enable state of, a group of registers.
    /// NVIC_ICERn[31:0] are the clear-enable bits for interrupts (31+(32*n)) - (32*n).
    /// When n=15, bits[31:16] are reserved
    ICER: [16]u32,
    _reserved1: [16]u32,
    /// Interrupt Set-Pending Registers, NVIC_ISPR0-NVIC_ISPR15:
    ///  For a group of interrupts, changes interrupt status to pending, or shows the current pending status.
    /// NVIC_ISPRn[31:0] are the set-pending bits for interrupts (31+(32*n)) - (32*n).
    /// When n=15, bits[31:16] are reserved
    ISPR: [16]u32,
    _reserved2: [16]u32,
    /// Interrupt Clear-Pending Registers, NVIC_ICPR0-NVIC_ICPR15:
    ///  For a group of interrupts, clears the interrupt pending status, or shows the current pending status.
    /// NVIC_ICPRn[31:0] are the clear-pending bits for interrupts (31+(32*n)) - (32*n).
    /// When n=15, bits[31:16] are reserved
    ICPR: [16]u32,
    _reserved3: [16]u32,
    ///  Interrupt Active Bit Registers, NVIC_IABR0-NVIC_IABR15:For a group of 32 interrupts, shows whether each interrupt is active.
    IABR: [16]u32,
    _reserved4: [48]u32,
    /// Interrupt Priority Registers, NVIC_IPR0-NVIC_IPR123: Sets or reads interrupt priorities
    IPR: [496]u8,
    _reserved5: [452]u32,
};
///   Memory Protection Unit
///     0xE000ED90-0xE000EDEF Memory Protection Unit
pub const MPU = extern struct {
    /// MPU Type Register, MPU_TYPE - The MPU Type Register indicates how many regions the MPU support.
    /// Software can use it to determine if the processor implements an MPU.
    TYPE: mmio.Mmio(packed struct(u32) {
        /// Indicates support for separate instruction and data address maps. RAZ. Armv7-M only
        /// supports a unified MPU.
        SEPERATE: u1,
        _reserved0: u7 = 0,
        /// Number of regions supported by the MPU. If this field reads-as-zero the processor does not
        /// implement an MPU.
        DREGION: u8,
        /// Instruction region. RAZ. Armv7-M only supports a unified MPU.
        IREGION: u8,
        _reserved1: u8 = 0,
    }),

    /// MPU Control Register, MPU_CTRL
    /// Enables the MPU, and when the MPU is enabled, controls whether the default memory map
    /// is enabled as a background region for privileged accesses, and whether the MPU is enabled
    /// for HardFaults, NMIs, and exception handlers when FAULTMASK is set to 1.
    CTRL: mmio.Mmio(packed struct(u32) {
        /// Enables the MPU
        ENABLE: u1,
        /// Enables MPU for Core interrupt handlers Hardfault, NMI, and and exception handlers when FAULTMASK is set to 1
        /// If HFNMIENA is set to 1 when ENABLE is set to 0, behavior is UNPREDICTABLE.
        HFNMIENA: u1,
        /// Enables the default memory map as a background region for privileged access.
        /// The background region acts as region number -1. All memory regions
        /// configured in the MPU take priority over the default memory map. The system
        /// address map on page B3-592 describes the default memory map.
        ///
        /// If Disabled Any instruction or data access that does not access a defined region faults.
        ///
        /// If no regions are enabled and the PRIVDEFENA and ENABLE bits are set to 1, only
        /// privileged code can execute from the system address map
        PRIVDEFENA: u1,
        _reserved0: u29 = 0,
    }),

    /// MPU Region Number Register, RNR - Selects the region currently accessed by MPU_RBAR and MPU_RASR.
    ///
    /// If an implementation supports N regions then the regions number from 0 to (N-1), and the
    /// effect of writing a value of N or greater to the REGION field is UNPREDICTABLE.
    RNR: mmio.Mmio(packed struct(u32) {
        /// Indicates the memory region accessed by MPU_RBAR and MPU_RASR.
        REGION: u8,
        _reserved0: u24 = 0,
    }),

    /// MPU Region Base Address Register, MPU_RBAR
    /// Holds the base address of the region identified by MPU_RNR. On a write, can also be used
    /// to update the base address of a specified region, in the range 0-5, updating MPU_RNR with
    /// the new region number
    ///
    /// The minimum region alignment required by an MPU_RBAR is IMPLEMENTATION
    /// DEFINED. See the register description for more information about permitted region sizes.
    ///
    /// If an implementation supports N regions then the regions number from 0 to (N-1). If
    /// N is less than 16 the effect of writing a value of N or greater to the REGION field is
    /// UNPREDICTABLE.
    RBAR: mmio.Mmio(packed struct(u32) {
        /// REGION
        /// On writes, can specify the number of the region to update, see VALID field description.
        /// On reads, returns bits[3:0] of MPU_RNR.
        REGION: u4,
        /// On writes, indicates whether the region to update is specified by MPU_RNR.REGION, or
        /// by the REGION value specified in this write. When using the REGION value specified by
        /// this write, MPU_RNR.REGION is updated to this value.
        ///
        /// 0 Apply the base address update to the region specified by MPU_RNR.REGION.
        /// The REGION field value is ignored.
        ///
        /// 1 Update MPU_RNR.REGION to the value obtained by zero extending the
        /// REGION value specified in this write, and apply the base address update to this region.
        ///
        /// This bit reads as zero.
        VALID: enum(u1) { USE_RNR, USE_REGION_TO_UPDATE_RNR },
        /// Base address of the region.
        ADDR: u27,
    }),

    /// MPU Region Attribute and Size Register, MPU_RASR - Defines the size and access behavior of the region identified by MPU_RNR,
    /// and enables that region.
    ///
    /// Writing a SIZE value less than the minimum size supported by the corresponding MPU_RBAR has an UNPREDICTABLE effect.
    RASR: mmio.Mmio(packed struct(u32) {
        /// Enables the region
        ENABLE: u1,
        /// Indicates the region size. The region size, in bytes, is 2(SIZE+1). SIZE field values less than 4
        /// are reserved, because the smallest supported region size is 32 bytes.
        SIZE: u5,
        _reserved0: u2 = 0,
        /// Subregion Disable. For regions of 256 bytes or larger, each bit of this field controls whether
        /// one of the eight equal subregions is enabled.
        SRD: u8,
        /// The MPU Region Attribute field, This field has the following subfields
        /// (MEMORY TYPE) - (Normal region Cacheability (if NORMAL)) - (Shareable)
        /// No-Cache - Non-cacheable
        /// WB Ra Wa - Write-Back, write and read allocate
        /// WT Ra Wn - Write-Through, no write allocate
        /// WB Ra Wn - Write-Back, no write allocate
        ATTRS_TEX_S_C_B: enum(u5) {
            @"Strongly Ordered - Sharable" = 0b000000,
            @"Device - Sharable",
            @"IMPLEMENTATION DEFINED" = 0b001010,
            @"Device - Non-shareable" = 0b010000,
            @"Normal - Outer: No-Cache, Inner: No-Cache - Non-shareable" = 0b100000,
            @"Normal - Outer: WB Ra Wa, Inner: No-Cache - Non-shareable",
            @"Normal - Outer: WT Ra Wn, Inner: No-Cache - Non-shareable",
            @"Normal - Outer: WB Ra Wn, Inner: No-Cache - Non-shareable",
            @"Normal - Outer: No-Cache, Inner: No-Cache - Sharable",
            @"Normal - Outer: WB Ra Wa, Inner: No-Cache - Sharable",
            @"Normal - Outer: WT Ra Wn, Inner: No-Cache - Sharable",
            @"Normal - Outer: WB Ra Wn, Inner: No-Cache - Sharable",
            @"Normal - Outer: No-Cache, Inner: WB Ra Wa - Non-shareable",
            @"Normal - Outer: WB Ra Wa, Inner: WB Ra Wa - Non-shareable",
            @"Normal - Outer: WT Ra Wn, Inner: WB Ra Wa - Non-shareable",
            @"Normal - Outer: WB Ra Wn, Inner: WB Ra Wa - Non-shareable",
            @"Normal - Outer: No-Cache, Inner: WB Ra Wa - Sharable",
            @"Normal - Outer: WB Ra Wa, Inner: WB Ra Wa - Sharable",
            @"Normal - Outer: WT Ra Wn, Inner: WB Ra Wa - Sharable",
            @"Normal - Outer: WB Ra Wn, Inner: WB Ra Wa - Sharable",
            @"Normal - Outer: No-Cache, Inner: WT Ra Wn - Non-shareable",
            @"Normal - Outer: WB Ra Wa, Inner: WT Ra Wn - Non-shareable",
            @"Normal - Outer: WT Ra Wn, Inner: WT Ra Wn - Non-shareable",
            @"Normal - Outer: WB Ra Wn, Inner: WT Ra Wn - Non-shareable",
            @"Normal - Outer: No-Cache, Inner: WT Ra Wn - Sharable",
            @"Normal - Outer: WB Ra Wa, Inner: WT Ra Wn - Sharable",
            @"Normal - Outer: WT Ra Wn, Inner: WT Ra Wn - Sharable",
            @"Normal - Outer: WB Ra Wn, Inner: WT Ra Wn - Sharable",
            @"Normal - Outer: No-Cache, Inner: WB Ra Wn - Non-shareable",
            @"Normal - Outer: WB Ra Wa, Inner: WB Ra Wn - Non-shareable",
            @"Normal - Outer: WT Ra Wn, Inner: WB Ra Wn - Non-shareable",
            @"Normal - Outer: WB Ra Wn, Inner: WB Ra Wn - Non-shareable",
            @"Normal - Outer: No-Cache, Inner: WB Ra Wn - Sharable",
            @"Normal - Outer: WB Ra Wa, Inner: WB Ra Wn - Sharable",
            @"Normal - Outer: WT Ra Wn, Inner: WB Ra Wn - Sharable",
            @"Normal - Outer: WB Ra Wn, Inner: WB Ra Wn - Sharable",
        },
        _reserved1: u2 = 0,
        /// Access permissions
        /// (Privileged) - (Unprivileged)
        /// NA - No access
        /// RW - Read and write
        /// RO - Read only
        AP: enum(u3) {
            @"Privileged_NA - Unprivileged_NA",
            @"Privileged_RW - Unprivileged_NA",
            @"Privileged_RW - Unprivileged_RO",
            @"Privileged_RW - Unprivileged_RW",
            @"Privileged_RO - Unprivileged_NA" = 0b101,
            @"Privileged_RO - Unprivileged_RO",
        },
        _reserved2: u2 = 0,
        ///Execute Never
        /// The XN bit provides an Execute Never capability.
        ///
        /// For the processor to execute an instruction, the instruction must be in a memory region with:
        /// • Read access, indicated by the AP bits, for the appropriate privilege level.
        /// • The XN bit set to 0.
        XN: u1,
        _reserved3: u3,
    }),
};

/// Bit manipulation regions and associated mappings/aliases
pub const bit_bands = struct {
    ///Memory details affecting peripherals and bits.
    pub const peripheral = struct {
        pub const region = struct { //Memory that can be minipulated by bitband bits.
            pub const start = 0x40100000;
            pub const end = 0x40000000;
        };
        pub const alias = struct { // Memory that can toggle individual bits.
            pub const start = 0x42000000;
            pub const end = 0x44000000;
        };
    };

    pub const sram = struct {
        pub const region = struct { //Memory that can be minipulated by bitband bits.
            pub const start = 0x20000000;
            pub const end = 0x20100000;
        };
        pub const alias = struct { // Memory that can toggle individual bits.
            pub const start = 0x22000000;
            pub const end = 0x24000000;
        };
    };
};

/// Debug Information
/// Instrumentation Trace Macrocell (ITM) 0xE0000000-0xE0000FFF The Instrumentation Trace Macrocell on page C1-709
pub const ITM = extern struct {
    /// ITM Stimulus                      0xE0000000-0xE00003FC ITM_STIMx RW UNKNOWN    Stimulus Port registers, ITM_STIM0-ITM_STIM255 on page C1-714
    /// Data write to the stimulus port FIFO, for forwarding as a software event packet. These bits are write-only.
    /// Bit 0 reads:
    /// 0  Stimulus port FIFO full.
    /// 1  Stimulus port FIFO can accept at least one word.
    ITM_STIM: [256]u32,
    RESERVED0: [640]u32,
    /// Trace Enable Registers,          0xE0000E00-0xE0000E1C ITM_TERx  RW 0x00000000 Trace Enable Registers, ITM_TER0-ITM_TER7 on page C1-714
    /// For bit[n], in register ITM_TERx:
    /// 0  Stimulus port (32x + n) disabled.
    /// 1  Stimulus port (32x + n) enabled.
    ITM_TER: [8]u32,
    RESERVED1: [32]u8,
    ///Trace Privilege Register, ITM_TPR  0xE0000E40            ITM_TPR   RW 0x00000000 Trace Privilege Register, ITM_TPR on page C1-715
    /// Controls which stimulus ports can be accessed by unprivileged code.
    /// Each register bit controls access to eight stimulus ports.
    /// • The number of implemented stimulus ports is a multiple of eight. Implemented stimulus ports number consecutively from 0.
    /// • Bits corresponding to unimplemented stimulus ports are RAZ/WI.
    ///
    /// Software can find the number of supported stimulus ports by writing all ones to the Trace Privilege Register, and then reading how many bits are set to 1.
    ///
    /// Bit[n] of ITM_TPR controls stimulus ports 8n to 8n+7:
    /// 0  Unprivileged access permitted.
    /// 1  Privileged access only.
    ITM_TPR: u32,
    RESERVED2: [60]u8,
    /// Trace Control Register, ITM_TCR   0xE0000E80            ITM_TCR   RW            Trace Control Register, ITM_TCR on page C1-716
    /// Configures and controls transfers through the ITM interface
    ITM_TCR: mmio.Mmio(packed struct(u32) {
        /// Enables the ITM
        /// This is the enable control for the ITM unit. A debugger must set this bit to 1 to permit writes to all Stimulus Port registers.
        /// A power-on reset clears this bit to 0.
        ITMENA: u1,
        /// Enables Local timestamp generation
        TSENA: u1,
        /// Enables Synchronization packet transmission for a synchronous TPIU
        SYNCENA: u1,
        /// Enables forwarding of hardware event packet from the DWT unit to the ITM for output to the TPIU.
        TXENA: u1,
        /// Enables asynchronous clocking of the timestamp counter
        SWOENA: u1,
        _reserved0: u3 = 0,
        /// Identifier for multi-source trace stream formatting. If multi-source trace is in use, the
        /// debugger must write a non-zero value to this field.
        TSPrescale: enum(u2) {
            @"No prescaling",
            @"Divide by 4",
            @"Divide by 16",
            @"Divide by 64",
        },
        /// Global timestamp frequency. Defines how often the ITM generates a global timestamp,
        /// based on the global timestamp clock frequency, or disables generation of global timestamps.
        GTSFREQ: enum(u2) {
            @"Disable generation of global timestamps",
            @"Generate timestamp request whenever the ITM detects a change in global timestamp counter bits[N:7]. This is approximately every 128 cycles",
            @"Generate timestamp request whenever the ITM detects a change in global timestamp counter bits[N:13]. This is approximately every 8192 cycles",
            @"Generate a timestamp after every packet, if the output FIFO is empty",
        },
        _reserved1: u4 = 0,
        /// Identifier for multi-source trace stream formatting. If multi-source trace is in use, the
        /// debugger must write a non-zero value to this field.
        TraceBusID: u7,
        /// BUSY: Indicates whether the ITM is currently processing events
        BUSY: u1,
    }),
    //                                    0xE0000FD0-0xE0000FFC                         Optional CoreSight management and ID registers. See Appendix D1
    //                                                                                  Armv7-M CoreSight Infrastructure IDs for more information.
};
//  Data Watchpoint and Trace (DWT) unit  0xE0001000-0xE0001FFF The Data Watchpoint and Trace unit on page C1-719
//  Flash Patch and Breakpoint (FPB) unit 0xE0002000-0xE0002FFF Flash Patch and Breakpoint unit on page C1-755
//  SCS                                   0xE000ED00-0xE000EFFF System Control Space (SCS) on page B3-595
//  System Control Block (SCB)            0xE000ED00-0xE000ED8F About the System Control Block on page B3-595
//  Debug Control Block (DCB)             0xE000EDF0-0xE000EEFF Debug system registers on page C1-699
//  Trace Port Interface Unit (TPIU)      0xE0040000-0xE0040FFF Trace Port Interface Unit on page C1-750
//  Embedded Trace Macrocell (ETM)        0xE0041000-0xE0041FFF Embedded Trace Macrocell support on page C1-749
//  IMPLEMENTATION DEFINED                0xE0042000-0xE00FEFFF -
//  ROM table                             0xE00FF000-0xE00FFFFF The Debug Access Port on page C1-686

pub const SystemControlBlock = SCB;
pub const NestedVectorInterruptController = NVIC;
pub const MemoryProtectionUnit = MPU;
pub const SysTick = Systick;
